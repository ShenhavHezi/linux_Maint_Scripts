#!/usr/bin/env bash
# linux-maint - CLI entrypoint for Linux_Maint_Scripts

set -euo pipefail

# If running from a git checkout, prefer repo paths automatically.
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

PREFIX="${PREFIX:-/usr/local}"
SBIN="$PREFIX/sbin"
LIBEXEC="$PREFIX/libexec/linux_maint"
SHARE="$PREFIX/share/linux_maint"

REPO_MONITORS="$REPO_ROOT/monitors"
REPO_LIB="$REPO_ROOT/lib/linux_maint.sh"
REPO_WRAPPER="$REPO_ROOT/run_full_health_monitor.sh"

# installed defaults
wrapper="$SBIN/run_full_health_monitor.sh"
preflight="$LIBEXEC/preflight_check.sh"
validate="$LIBEXEC/config_validate.sh"

if [[ -d "$REPO_MONITORS" && -f "$REPO_LIB" ]]; then
  # repo mode
  export LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-$REPO_LIB}"
  export LM_LOCKDIR="${LM_LOCKDIR:-/tmp}"
  export LM_LOGFILE="${LM_LOGFILE:-/tmp/linux_maint.log}"
  wrapper="$REPO_WRAPPER"
  preflight="$REPO_MONITORS/preflight_check.sh"
  validate="$REPO_MONITORS/config_validate.sh"
fi

MODE="installed"
[[ "$wrapper" == "$REPO_WRAPPER" ]] && MODE="repo"
REPO_LOG_DIR="$REPO_ROOT/.logs"
REPO_STATUS_FILE="$REPO_LOG_DIR/last_status_full"
REPO_LATEST_LOG="$REPO_LOG_DIR/full_health_monitor_latest.log"
REPO_SUMMARY_LATEST="$REPO_LOG_DIR/full_health_monitor_summary_latest.log"
INST_SUMMARY_LATEST="/var/log/health/full_health_monitor_summary_latest.log"


need_root_for(){
  local cmd="$1"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    echo "ERROR: linux-maint $cmd requires root (installed mode)." >&2
    case "$cmd" in
      run)
        echo "Hint: sudo linux-maint run" >&2
        echo "      (or run the wrapper directly: sudo /usr/local/sbin/run_full_health_monitor.sh)" >&2
        ;;
      status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi

    if [[ "$MODE" == "repo" ]]; then
      echo "=== Mode ==="
      echo "repo"
      echo "repo_root: $REPO_ROOT"
      echo "linux_maint_lib: ${LINUX_MAINT_LIB:-}"
      echo "logs: $REPO_LOG_DIR"
      echo ""; echo "=== Last run status ==="
      if [[ -f "$REPO_STATUS_FILE" ]]; then
        cat "$REPO_STATUS_FILE"
      else
        echo "No status file: $REPO_STATUS_FILE"
      fi
    else
      status_file="/var/log/health/last_status_full"
      echo "=== Mode ==="
      echo "installed"
      echo "prefix: $PREFIX"
      echo ""; echo "=== Installed paths ==="
      echo "wrapper: $SBIN/run_full_health_monitor.sh"
      echo "libexec: $LIBEXEC"
      echo "build_info: $SHARE/BUILD_INFO"
      [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
      echo ""; echo "=== Last run status ==="
      if [[ -f "$status_file" ]]; then
        cat "$status_file"
      else
        echo "No status file: $status_file"
      fi
    fi

    echo ""; echo "=== Summary (monitor= lines) ==="
    summary_file=""
    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
    else
      summary_file="$INST_SUMMARY_LATEST"
    fi

    if [[ -f "$summary_file" ]]; then
      echo "(from summary file: $summary_file)"
      tail -n 200 "$summary_file" || true
    else
      echo "No summary file: $summary_file"
      echo "Falling back to grepping latest wrapper log"
      log="/var/log/health/full_health_monitor_latest.log"
      [[ "$MODE" == "repo" ]] && log="$REPO_LATEST_LOG"
      if [[ -f "$log" ]]; then
        grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT|FINAL_STATUS_SUMMARY|^\\[.*\\] monitor=" "$log" | tail -n 120 || true
      else
        echo "No log: $log"
      fi
    fi
    ;;
      logs)
        echo "Hint: sudo linux-maint logs 200" >&2
        ;;
      preflight)
        echo "Hint: sudo linux-maint preflight" >&2
        ;;
      validate)
        echo "Hint: sudo linux-maint validate" >&2
        ;;
      *)
        echo "Hint: sudo linux-maint $cmd" >&2
        ;;
    esac
    exit 1
  fi
}


usage(){
  cat <<EOF2
Usage: linux-maint <command> [args]

Commands:
  run                 Run the full package (wrapper)
  status              Show last run status + recent WARN/CRIT lines
  validate            Validate config file formats (best-effort)
  preflight           Run preflight checks
  version             Print installed BUILD_INFO (if present)
  install [args]      Run ./install.sh (pass-through)
  uninstall [args]    Run ./install.sh --uninstall (pass-through)
  make-tarball        Build offline release tarball (tools/make_tarball.sh)
  logs [n]            Tail latest wrapper log (default n=200)
  help                Show this help

Environment:
  PREFIX=/usr/local             installation prefix override
  LINUX_MAINT_LIB=...           override library path (useful in repo mode)
  LM_LOCKDIR=/tmp               override lock dir (useful when not root)
  LM_LOGFILE=/tmp/linux_maint.log override default log file
EOF2
}

cmd="${1:-help}"; shift || true

case "$cmd" in
  help|-h|--help)
    usage
    ;;

  run)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run
    fi
    # In installed mode, try sudo -n first. In repo mode, just run.
    if [[ "$wrapper" == "$SBIN"/* ]]; then
      exec sudo -n "$wrapper" 2>/dev/null || exec "$wrapper"
    else
      exec bash "$wrapper"
    fi
    ;;

  logs)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for logs
    fi
        n="${1:-200}"
        if [[ "$MODE" == "repo" ]]; then
          mkdir -p "$REPO_LOG_DIR"
          [[ -f "$REPO_LATEST_LOG" ]] || { echo "No repo log yet: $REPO_LATEST_LOG"; exit 1; }
          tail -n "$n" "$REPO_LATEST_LOG"
        else
          exec sudo -n tail -n "$n" /var/log/health/full_health_monitor_latest.log 2>/dev/null || tail -n "$n" /var/log/health/full_health_monitor_latest.log
        fi
    ;;

  version)
    if [[ -f "$SHARE/BUILD_INFO" ]]; then
      cat "$SHARE/BUILD_INFO"
    else
      echo "BUILD_INFO not found at $SHARE/BUILD_INFO"
      exit 1
    fi
    ;;

  preflight)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for preflight
    fi
    exec bash "$preflight"
    ;;

  validate)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for validate
    fi
    exec bash "$validate"
    ;;

  status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi

    if [[ "$MODE" == "repo" ]]; then
      echo "=== Mode ==="
      echo "repo"
      echo "repo_root: $REPO_ROOT"
      echo "linux_maint_lib: ${LINUX_MAINT_LIB:-}"
      echo "logs: $REPO_LOG_DIR"
      echo ""; echo "=== Last run status ==="
      if [[ -f "$REPO_STATUS_FILE" ]]; then
        cat "$REPO_STATUS_FILE"
      else
        echo "No status file: $REPO_STATUS_FILE"
      fi
    else
      status_file="/var/log/health/last_status_full"
      echo "=== Mode ==="
      echo "installed"
      echo "prefix: $PREFIX"
      echo ""; echo "=== Installed paths ==="
      echo "wrapper: $SBIN/run_full_health_monitor.sh"
      echo "libexec: $LIBEXEC"
      echo "build_info: $SHARE/BUILD_INFO"
      [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
      echo ""; echo "=== Last run status ==="
      if [[ -f "$status_file" ]]; then
        cat "$status_file"
      else
        echo "No status file: $status_file"
      fi
    fi

    echo ""; echo "=== Summary (monitor= lines) ==="
    summary_file=""
    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
    else
      summary_file="$INST_SUMMARY_LATEST"
    fi

    if [[ -f "$summary_file" ]]; then
      echo "(from summary file: $summary_file)"
      tail -n 200 "$summary_file" || true
    else
      echo "No summary file: $summary_file"
      echo "Falling back to grepping latest wrapper log"
      log="/var/log/health/full_health_monitor_latest.log"
      [[ "$MODE" == "repo" ]] && log="$REPO_LATEST_LOG"
      if [[ -f "$log" ]]; then
        grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT|FINAL_STATUS_SUMMARY|^\\[.*\\] monitor=" "$log" | tail -n 120 || true
      else
        echo "No log: $log"
      fi
    fi
    ;;

  install)
    exec sudo ./install.sh "$@"
    ;;

  uninstall)
    exec sudo ./install.sh --uninstall "$@"
    ;;

  make-tarball)
    exec ./tools/make_tarball.sh "$@"
    ;;

  init)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for init
    fi

    CFG_DIR="/etc/linux_maint"
    SRC_DIR="$REPO_ROOT/etc/linux_maint"
    if [[ "$MODE" == "installed" && ! -d "$SRC_DIR" ]]; then
      # When running the installed CLI, REPO_ROOT points to /usr/local/bin/.. which is not a checkout.
      # User should run init from a git checkout OR copy templates manually.
      SRC_DIR=""
    fi
    if [[ -z "$SRC_DIR" || ! -d "$SRC_DIR" ]]; then
      echo "ERROR: templates not found at $SRC_DIR" >&2
      echo "Run init from a git checkout:" >&2
      echo "  git clone https://github.com/ShenhavHezi/linux_Maint_Scripts.git" >&2
      echo "  cd linux_Maint_Scripts" >&2
      echo "  sudo ./bin/linux-maint init" >&2
      exit 1
    fi

    sudo mkdir -p "$CFG_DIR" "$CFG_DIR/baselines" "$CFG_DIR/baselines/ports" "$CFG_DIR/baselines/configs" "$CFG_DIR/baselines/users" "$CFG_DIR/baselines/sudoers"

    shopt -s nullglob
    for f in "$SRC_DIR"/*.example; do
      base="$(basename "$f" .example)"
      dest="$CFG_DIR/$base"
      if [[ -e "$dest" ]]; then
        echo "keep:   $dest (exists)"
      else
        sudo install -m 0644 "$f" "$dest"
        echo "create: $dest"
      fi
    done

    echo ""
    echo "Next steps:"
    echo "  - Edit /etc/linux_maint/servers.txt"
    echo "  - Run: sudo linux-maint doctor"
    ;;

  doctor)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for doctor
    fi

    echo "=== linux-maint doctor ==="
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    echo "wrapper=$wrapper"
    echo "libexec=$LIBEXEC"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    echo "== Files =="
    for path in "$wrapper" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"; do
      if [[ -e "$path" ]]; then ls -la "$path"; else echo "MISSING: $path"; fi
    done
    if [[ "$MODE" == "installed" ]]; then
      [[ -d "$LIBEXEC" ]] && ls -ld "$LIBEXEC" || echo "MISSING: $LIBEXEC"
    else
      [[ -d "$REPO_MONITORS" ]] && ls -ld "$REPO_MONITORS" || echo "MISSING: $REPO_MONITORS"
    fi

    echo "== Config =="
    for f in /etc/linux_maint/servers.txt /etc/linux_maint/excluded.txt /etc/linux_maint/services.txt /etc/linux_maint/emails.txt; do
      [[ -e "$f" ]] && echo "OK: $f" || echo "MISSING: $f"
    done

    echo "== Can write state/logs? =="
    for d in /var/log/health /var/log/inventory /var/lib/linux_maint /var/lock; do
      [[ -d "$d" ]] || { echo "NOTE: creating $d"; sudo mkdir -p "$d" 2>/dev/null || true; }
      if touch "$d/.lm_write_test" 2>/dev/null; then rm -f "$d/.lm_write_test"; echo "OK: writable $d"; else echo "WARN: not writable $d"; fi
    done

    echo "== Next recommended actions =="
    echo "- sudo linux-maint init      # if config is missing"
    echo "- sudo linux-maint preflight"
    echo "- sudo linux-maint run"
    ;;

  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac
