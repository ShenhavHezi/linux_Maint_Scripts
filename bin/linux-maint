#!/usr/bin/env bash
# linux-maint - CLI entrypoint for Linux_Maint_Scripts

set -euo pipefail

# If running from a git checkout, prefer repo paths automatically.
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

PREFIX="${PREFIX:-/usr/local}"
SBIN="$PREFIX/sbin"
LIBEXEC="$PREFIX/libexec/linux_maint"
SHARE="$PREFIX/share/linux_maint"

REPO_MONITORS="$REPO_ROOT/monitors"
REPO_LIB="$REPO_ROOT/lib/linux_maint.sh"
REPO_WRAPPER="$REPO_ROOT/run_full_health_monitor.sh"

# installed defaults
wrapper="$SBIN/run_full_health_monitor.sh"
preflight="$LIBEXEC/preflight_check.sh"
validate="$LIBEXEC/config_validate.sh"

if [[ -d "$REPO_MONITORS" && -f "$REPO_LIB" ]]; then
  # repo mode
  export LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-$REPO_LIB}"
  export LM_LOCKDIR="${LM_LOCKDIR:-/tmp}"
  export LM_LOGFILE="${LM_LOGFILE:-/tmp/linux_maint.log}"
  wrapper="$REPO_WRAPPER"
  preflight="$REPO_MONITORS/preflight_check.sh"
  validate="$REPO_MONITORS/config_validate.sh"
fi

MODE="installed"
[[ "$wrapper" == "$REPO_WRAPPER" ]] && MODE="repo"
REPO_LOG_DIR="$REPO_ROOT/.logs"
REPO_STATUS_FILE="$REPO_LOG_DIR/last_status_full"
REPO_LATEST_LOG="$REPO_LOG_DIR/full_health_monitor_latest.log"


need_root_for(){
  local cmd="$1"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    echo "ERROR: linux-maint $cmd requires root (installed mode)." >&2
    case "$cmd" in
      run)
        echo "Hint: sudo linux-maint run" >&2
        echo "      (or run the wrapper directly: sudo /usr/local/sbin/run_full_health_monitor.sh)" >&2
        ;;
      status)
        echo "Hint: sudo linux-maint status" >&2
        ;;
      logs)
        echo "Hint: sudo linux-maint logs 200" >&2
        ;;
      preflight)
        echo "Hint: sudo linux-maint preflight" >&2
        ;;
      validate)
        echo "Hint: sudo linux-maint validate" >&2
        ;;
      *)
        echo "Hint: sudo linux-maint $cmd" >&2
        ;;
    esac
    exit 1
  fi
}


usage(){
  cat <<EOF2
Usage: linux-maint <command> [args]

Commands:
  run                 Run the full package (wrapper)
  status              Show last run status + recent WARN/CRIT lines
  validate            Validate config file formats (best-effort)
  preflight           Run preflight checks
  version             Print installed BUILD_INFO (if present)
  install [args]      Run ./install.sh (pass-through)
  uninstall [args]    Run ./install.sh --uninstall (pass-through)
  make-tarball        Build offline release tarball (tools/make_tarball.sh)
  logs [n]            Tail latest wrapper log (default n=200)
  help                Show this help

Environment:
  PREFIX=/usr/local             installation prefix override
  LINUX_MAINT_LIB=...           override library path (useful in repo mode)
  LM_LOCKDIR=/tmp               override lock dir (useful when not root)
  LM_LOGFILE=/tmp/linux_maint.log override default log file
EOF2
}

cmd="${1:-help}"; shift || true

case "$cmd" in
  help|-h|--help)
    usage
    ;;

  run)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run
    fi
    # In installed mode, try sudo -n first. In repo mode, just run.
    if [[ "$wrapper" == "$SBIN"/* ]]; then
      exec sudo -n "$wrapper" 2>/dev/null || exec "$wrapper"
    else
      exec bash "$wrapper"
    fi
    ;;

  logs)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for logs
    fi
        n="${1:-200}"
        if [[ "$MODE" == "repo" ]]; then
          mkdir -p "$REPO_LOG_DIR"
          [[ -f "$REPO_LATEST_LOG" ]] || { echo "No repo log yet: $REPO_LATEST_LOG"; exit 1; }
          tail -n "$n" "$REPO_LATEST_LOG"
        else
          exec sudo -n tail -n "$n" /var/log/health/full_health_monitor_latest.log 2>/dev/null || tail -n "$n" /var/log/health/full_health_monitor_latest.log
        fi
    ;;

  version)
    if [[ -f "$SHARE/BUILD_INFO" ]]; then
      cat "$SHARE/BUILD_INFO"
    else
      echo "BUILD_INFO not found at $SHARE/BUILD_INFO"
      exit 1
    fi
    ;;

  preflight)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for preflight
    fi
    exec bash "$preflight"
    ;;

  validate)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for validate
    fi
    exec bash "$validate"
    ;;

  status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi
        if [[ "$MODE" == "repo" ]]; then
          echo "=== Mode ==="
          echo "repo"
          echo "repo_root: $REPO_ROOT"
          echo "linux_maint_lib: ${LINUX_MAINT_LIB:-}"
          echo "logs: $REPO_LOG_DIR"
          echo ""; echo "=== Last run status ==="
          if [[ -f "$REPO_STATUS_FILE" ]]; then
            cat "$REPO_STATUS_FILE"
          else
            echo "No status file: $REPO_STATUS_FILE"
          fi
          echo ""; echo "=== Recent WARN/CRIT/UNKNOWN lines (latest log) ==="
          if [[ -f "$REPO_LATEST_LOG" ]]; then
            grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT" "$REPO_LATEST_LOG" | tail -n 80 || true
          else
            echo "No log: $REPO_LATEST_LOG"
          fi
          exit 0
        fi
        status_file="/var/log/health/last_status_full"
        echo "=== Mode ==="
        echo "installed"
        echo "prefix: $PREFIX"
        echo ""; echo "=== Installed paths ==="
        echo "wrapper: $SBIN/run_full_health_monitor.sh"
        echo "libexec: $LIBEXEC"
        echo "build_info: $SHARE/BUILD_INFO"
        [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
        echo ""; echo "=== Last run status ==="
        if [[ -f "$status_file" ]]; then
          cat "$status_file"
        else
          echo "No status file: $status_file"
        fi
        echo ""; echo "=== Recent WARN/CRIT/UNKNOWN lines (latest log) ==="
        log="/var/log/health/full_health_monitor_latest.log"
        if [[ -f "$log" ]]; then
          grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT" "$log" | tail -n 80 || true
        else
          echo "No log: $log"
        fi
    ;;

  install)
    exec sudo ./install.sh "$@"
    ;;

  uninstall)
    exec sudo ./install.sh --uninstall "$@"
    ;;

  make-tarball)
    exec ./tools/make_tarball.sh "$@"
    ;;

  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac
