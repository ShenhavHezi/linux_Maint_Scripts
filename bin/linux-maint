#!/usr/bin/env bash
# linux-maint - CLI entrypoint for Linux_Maint_Scripts

set -euo pipefail

# If running from a git checkout, prefer repo paths automatically.
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

PREFIX="${PREFIX:-/usr/local}"
SBIN="$PREFIX/sbin"
LIBEXEC="$PREFIX/libexec/linux_maint"
SHARE="$PREFIX/share/linux_maint"

REPO_MONITORS="$REPO_ROOT/monitors"
REPO_LIB="$REPO_ROOT/lib/linux_maint.sh"
REPO_WRAPPER="$REPO_ROOT/run_full_health_monitor.sh"

# installed defaults
wrapper="$SBIN/run_full_health_monitor.sh"
preflight="$LIBEXEC/preflight_check.sh"
validate="$LIBEXEC/config_validate.sh"

if [[ -d "$REPO_MONITORS" && -f "$REPO_LIB" ]]; then
  # repo mode
  export LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-$REPO_LIB}"
  export LM_LOCKDIR="${LM_LOCKDIR:-/tmp}"
  export LM_LOGFILE="${LM_LOGFILE:-/tmp/linux_maint.log}"
  wrapper="$REPO_WRAPPER"
  preflight="$REPO_MONITORS/preflight_check.sh"
  validate="$REPO_MONITORS/config_validate.sh"
fi

MODE="installed"
[[ "$wrapper" == "$REPO_WRAPPER" ]] && MODE="repo"
REPO_LOG_DIR="$REPO_ROOT/.logs"
REPO_STATUS_FILE="$REPO_LOG_DIR/last_status_full"
REPO_LATEST_LOG="$REPO_LOG_DIR/full_health_monitor_latest.log"
REPO_SUMMARY_LATEST="$REPO_LOG_DIR/full_health_monitor_summary_latest.log"
INST_SUMMARY_LATEST="/var/log/health/full_health_monitor_summary_latest.log"


need_root_for(){
  local cmd="$1"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    echo "ERROR: linux-maint $cmd requires root (installed mode)." >&2
    case "$cmd" in
      run)
        echo "Hint: sudo linux-maint run" >&2
        echo "      (or run the wrapper directly: sudo /usr/local/sbin/run_full_health_monitor.sh)" >&2
        ;;
      status)
        echo "Hint: sudo linux-maint status" >&2
        ;;
      logs)
        echo "Hint: sudo linux-maint logs 200" >&2
        ;;
      preflight)
        echo "Hint: sudo linux-maint preflight" >&2
        ;;
      validate)
        echo "Hint: sudo linux-maint validate" >&2
        ;;
      *)
        echo "Hint: sudo linux-maint $cmd" >&2
        ;;
    esac
    exit 1
  fi
}


validate_ssh_opts(){
  # Reject obviously dangerous shell metacharacters.
  # NOTE: LM_SSH_OPTS is split into argv for ssh; this check reduces the risk of accidental injection.
  local s="${LM_SSH_OPTS:-}"
  [[ -z "$s" ]] && return 0

  # Disallow shell metacharacters and newlines/carriage returns.
  if printf '%s' "$s" | grep -Eq '[;&|`<>]|\$\(|\$\{|\r|\n'; then
    echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
    echo "LM_SSH_OPTS=$s" >&2
    exit 2
  fi
}



# ---- run() flags parsing (CLI-first, env-compatible) ----
# Maps:
#   --group G        -> LM_GROUP
#   --hosts a,b      -> LM_SERVERLIST (temp file)
#   --exclude a,b    -> LM_EXCLUDED (temp file)
#   --parallel N     -> LM_MAX_PARALLEL
#   --local-only     -> LM_LOCAL_ONLY=true
#   --ssh-opts "..." -> LM_SSH_OPTS
#   --dry-run        -> print resolved hosts and exit
#
_run_tmpfiles=()
cleanup_tmpfiles(){
  for f in "${_run_tmpfiles[@]:-}"; do rm -f "$f" 2>/dev/null || true; done
}
trap cleanup_tmpfiles EXIT

make_list_tmpfile(){
  local csv="$1" prefix="$2"
  local f
  f="$(mktemp "/tmp/linux_maint_${prefix}.XXXXXX")"
  _run_tmpfiles+=("$f")
  # split on comma and whitespace
  echo "$csv" | tr ',' '\n' | awk '{gsub(/^[ \t]+|[ \t]+$/,"",$0); if($0!="") print $0}' > "$f"
  echo "$f"
}

parse_run_args(){
  DRY_RUN=0
  DEBUG=0
  LIMIT=0
  SHUFFLE=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --group)
        LM_GROUP="$2"; export LM_GROUP; shift 2;;
      --hosts)
        tmpf="$(make_list_tmpfile "$2" hosts)"; LM_SERVERLIST="$tmpf"; export LM_SERVERLIST; shift 2;;
      --exclude)
        tmpf="$(make_list_tmpfile "$2" excluded)"; LM_EXCLUDED="$tmpf"; export LM_EXCLUDED; shift 2;;
      --parallel)
        LM_MAX_PARALLEL="$2"; export LM_MAX_PARALLEL; shift 2;;
      --local-only)
        LM_LOCAL_ONLY="true"; export LM_LOCAL_ONLY; shift 1;;
      --ssh-opts)
        LM_SSH_OPTS="$2"; export LM_SSH_OPTS; shift 2;;
      --limit)
        LIMIT="$2"; shift 2;;
      --shuffle)
        SHUFFLE=1; shift 1;;
      --debug|--print-env)
        DEBUG=1; shift 1;;
      --dry-run)
        DRY_RUN=1; shift 1;;
      -h|--help)
        echo "Usage: linux-maint run [--group G] [--hosts h1,h2] [--exclude h3,h4] [--parallel N] [--local-only] [--ssh-opts '...'] [--limit N] [--shuffle] [--debug|--print-env] [--dry-run]"
        exit 0;;
      *)
        echo "Unknown run flag: $1" >&2
        exit 2;;
    esac
  done
}


usage(){
  cat <<EOF2
Usage: linux-maint <command> [args]

Commands:
  run [flags]         Run the full package (wrapper)
  status [--only S] [--host P] [--monitor P] [--tail N]  Show last run status + filtered summary lines
  diff [--json]       Show diff since last run (uses wrapper diff state)
  validate            Validate config file formats (best-effort)
  preflight           Run preflight checks
  version             Print installed BUILD_INFO (if present)
  install [args]      Run ./install.sh (pass-through)
  uninstall [args]    Run ./install.sh --uninstall (pass-through)
  make-tarball        Build offline release tarball (tools/make_tarball.sh)
  logs [n]            Tail latest wrapper log (default n=200)
  init                Install /etc/linux_maint templates (from repo checkout)
  doctor              Diagnose installation/config/state permissions
  help                Show this help

Environment:
  PREFIX=/usr/local             installation prefix override
  LINUX_MAINT_LIB=...           override library path (useful in repo mode)
  LM_LOCKDIR=/tmp               override lock dir (useful when not root)
  LM_LOGFILE=/tmp/linux_maint.log override default log file
EOF2
}

cmd="${1:-help}"; shift || true

case "$cmd" in
  help|-h|--help)
    usage
    ;;

  run)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run
    fi
    parse_run_args "$@"
    validate_ssh_opts

    if [[ "${DEBUG:-0}" -eq 1 ]]; then
      echo "=== linux-maint run debug ==="
      echo "MODE=${MODE}"
      echo "wrapper=${wrapper}"
      echo "LM_GROUP=${LM_GROUP:-}"
      echo "LM_HOSTS_DIR=${LM_HOSTS_DIR:-}"
      echo "LM_SERVERLIST=${LM_SERVERLIST:-}"
      echo "LM_EXCLUDED=${LM_EXCLUDED:-}"
      echo "LM_MAX_PARALLEL=${LM_MAX_PARALLEL:-}"
      echo "LM_LOCAL_ONLY=${LM_LOCAL_ONLY:-}"
      echo "LM_SSH_OPTS=${LM_SSH_OPTS:-}"
      echo "LIMIT=${LIMIT:-0}"
      echo "SHUFFLE=${SHUFFLE:-0}"
      echo "DRY_RUN=${DRY_RUN:-0}"
      echo "============================="
    fi

    if [[ "${DRY_RUN:-0}" -eq 1 ]]; then
      if [[ -n "${LM_GROUP:-}" ]]; then
        gf="${LM_HOSTS_DIR:-/etc/linux_maint/hosts.d}/${LM_GROUP}.txt"
        [[ -f "$gf" ]] || echo "NOTE: LM_GROUP=$LM_GROUP but group file not found: $gf (will fall back)" >&2
      fi

      # best-effort host resolution using library if available
      if [[ -f "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" ]]; then
        # shellcheck disable=SC1090
        . "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" >/dev/null 2>&1 || true
        if command -v lm_hosts >/dev/null 2>&1; then
          mapfile -t _hosts < <(lm_hosts)
          if [[ "${SHUFFLE:-0}" -eq 1 ]]; then
            mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | shuf)
          fi
          if [[ "${LIMIT:-0}" -gt 0 ]]; then
            mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | head -n "${LIMIT}")
          fi

          echo "Resolved hosts (${#_hosts[@]}):"
          printf '%s\n' "${_hosts[@]}"
          exit 0
        fi
      fi
      echo "DRY RUN requested, but cannot resolve hosts (library not available)." >&2
      exit 0
    fi

    # In installed mode, try sudo -n first. In repo mode, just run.
    if [[ "$wrapper" == "$SBIN"/* ]]; then
      exec sudo -n "$wrapper" 2>/dev/null || exec "$wrapper"
    else
      exec bash "$wrapper"
    fi
    ;;


  diff)
    # Show diff of monitor= lines since last run.
    # Uses the same state file as the wrapper: last_summary_monitor_lines.log
    JSON=0
    if [[ "${1:-}" == "--json" ]]; then JSON=1; shift; fi

    if [[ "$MODE" == "repo" ]]; then
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-$REPO_LOG_DIR}}"
      SUMMARY_LATEST="$REPO_SUMMARY_LATEST"
    else
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"
      SUMMARY_LATEST="$INST_SUMMARY_LATEST"
    fi
    PREV_SUMMARY="$DIFF_STATE_DIR/last_summary_monitor_lines.log"
    CUR_SUMMARY="$SUMMARY_LATEST"

    if [[ ! -f "$CUR_SUMMARY" ]]; then
      echo "No current summary file: $CUR_SUMMARY" >&2
      echo "Run linux-maint run first." >&2
      exit 1
    fi
    if [[ ! -f "$PREV_SUMMARY" ]]; then
      echo "No previous diff state file: $PREV_SUMMARY" >&2
      echo "The wrapper creates this after the *second* run. Run linux-maint run again." >&2
      exit 1
    fi

    if [[ "$MODE" == "repo" ]]; then
      diff_tool="$REPO_ROOT/tools/summary_diff.py"
    else
      diff_tool="$LIBEXEC/summary_diff.py"
    fi
    if [[ ! -x "$diff_tool" ]]; then
      # In installed mode, tools/ may not exist; try a system python module not available; fallback to error.
      echo "Diff tool not found/executable: $diff_tool" >&2
      echo "Hint: ensure summary_diff.py is installed (expected at $LIBEXEC/summary_diff.py)" >&2
      exit 1
    fi

    if [[ "$JSON" -eq 1 ]]; then
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY" --json
    else
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY"
    fi
    ;;
  logs)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for logs
    fi
        n="${1:-200}"
        if [[ "$MODE" == "repo" ]]; then
          mkdir -p "$REPO_LOG_DIR"
          [[ -f "$REPO_LATEST_LOG" ]] || { echo "No repo log yet: $REPO_LATEST_LOG"; exit 1; }
          tail -n "$n" "$REPO_LATEST_LOG"
        else
          exec sudo -n tail -n "$n" /var/log/health/full_health_monitor_latest.log 2>/dev/null || tail -n "$n" /var/log/health/full_health_monitor_latest.log
        fi
    ;;

  version)
    if [[ -f "$SHARE/BUILD_INFO" ]]; then
      cat "$SHARE/BUILD_INFO"
    else
      echo "BUILD_INFO not found at $SHARE/BUILD_INFO"
      exit 1
    fi
    ;;

  preflight)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for preflight
    fi
    exec bash "$preflight"
    ;;

  validate)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for validate
    fi
    exec bash "$validate"
    ;;

  status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi

    ONLY=""
    TAIL_N=200
    VERBOSE=0
    QUIET=0
    PROB_N=20

    while [[ $# -gt 0 ]]; do
      case "$1" in
        --only) ONLY="$2"; shift 2;;
        --tail) TAIL_N="$2"; shift 2;;
        --verbose) VERBOSE=1; shift 1;;
        --quiet) QUIET=1; shift 1;;
        --problems) PROB_N="$2"; shift 2;;
        -h|--help)
          echo "Usage: linux-maint status [--only OK|WARN|CRIT|UNKNOWN|SKIP] [--tail N] [--verbose] [--quiet] [--problems N (max 100)]"
          exit 0;;
        *) echo "Unknown status flag: $1" >&2; exit 2;;
      esac
    done

    # Validate/cap PROB_N (default 20, max 100)
    if [[ ! "$PROB_N" =~ ^[0-9]+$ ]]; then
      PROB_N=20
    elif (( PROB_N > 100 )); then
      PROB_N=100
    elif (( PROB_N < 0 )); then
      PROB_N=0
    fi
    if [[ "$QUIET" -eq 0 ]]; then

    if [[ "$MODE" == "repo" ]]; then
      echo "=== Mode ==="
      echo "repo"
      echo "repo_root: $REPO_ROOT"
      echo "linux_maint_lib: ${LINUX_MAINT_LIB:-}"
      echo "logs: $REPO_LOG_DIR"
      echo ""; echo "=== Last run status ==="
      if [[ -f "$REPO_STATUS_FILE" ]]; then
        cat "$REPO_STATUS_FILE"
      else
        echo "No status file: $REPO_STATUS_FILE"
      fi
    else
      status_file="/var/log/health/last_status_full"
      echo "=== Mode ==="
      echo "installed"
      echo "prefix: $PREFIX"
      echo ""; echo "=== Installed paths ==="
      echo "wrapper: $SBIN/run_full_health_monitor.sh"
      echo "libexec: $LIBEXEC"
      echo "build_info: $SHARE/BUILD_INFO"
      [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
      echo ""; echo "=== Last run status ==="
      if [[ -f "$status_file" ]]; then
        cat "$status_file"
      else
        echo "No status file: $status_file"
      fi
    fi

    fi

    # Default: compact summary (hide OK). Use --verbose to show full tail of summary file.
    VERBOSE=${VERBOSE:-0}

    if [[ "$QUIET" -eq 0 ]]; then
      echo ""; echo "=== Summary (compact) ==="
    fi
    summary_file=""
    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
    else
      summary_file="$INST_SUMMARY_LATEST"
    fi

    if [[ -f "$summary_file" ]]; then
      if [[ "$VERBOSE" -eq 1 ]]; then
        echo "(verbose; last $TAIL_N lines from: $summary_file)"
        tail -n "$TAIL_N" "$summary_file" || true
      else
        [[ "$QUIET" -eq 0 ]] && echo "(from: $summary_file)"
        python3 - "$summary_file" "$ONLY" "$PROB_N" <<'PY'
import re, sys
path, only, limit = sys.argv[1:4]
limit=int(limit)

# Example line:
# monitor=config_validate host=localhost status=WARN node=localhost warn=1 crit=0 reason=...

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

counts={}
problems=[]
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line:
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        if only and st != only:
            continue
        counts[st]=counts.get(st,0)+1
        if st == 'OK':
            continue
        mon=get_kv(line,'monitor') or 'unknown_monitor'
        reason=get_kv(line,'reason')
        # Format D: "STATUS monitor reason=..." (reason only if exists)
        if reason:
            problems.append(f"{st} {mon} reason={reason}")
        else:
            problems.append(f"{st} {mon}")

order=['CRIT','WARN','UNKNOWN','SKIP','OK']
print('totals: ' + ' '.join(f"{k}={counts.get(k,0)}" for k in order))

if problems:
    print("\nproblems:")
    sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3}
    problems.sort(key=lambda s: sev_order.get(s.split(' ',1)[0], 9))
    for l in problems[:limit]:
        print(l)
else:
    print('\nproblems: none (all OK)')
PY
      fi
    else
      echo "No summary file: $summary_file"
      echo "Possible reasons:"
      echo "- linux-maint has not been run yet"
      echo "- wrapper ran with a different LOG_DIR/SUMMARY_DIR"
      echo "- permission issue creating/writing in /var/log/health (try sudo)"
      echo "Tips:"
      echo "- Run: sudo linux-maint run"
      echo "- Or inspect latest wrapper log: sudo linux-maint logs 200"
      echo "- Or run: sudo linux-maint doctor"
      echo "Falling back to grepping latest wrapper log"
      log="/var/log/health/full_health_monitor_latest.log"
      [[ "$MODE" == "repo" ]] && log="$REPO_LATEST_LOG"
      if [[ -f "$log" ]]; then
        grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT|FINAL_STATUS_SUMMARY|^\\[.*\\] monitor=" "$log" | tail -n 120 || true
      else
        echo "No log: $log"
      fi
    fi
    ;;

  install)
    exec sudo ./install.sh "$@"
    ;;

  uninstall)
    exec sudo ./install.sh --uninstall "$@"
    ;;

  make-tarball)
    exec ./tools/make_tarball.sh "$@"
    ;;

  init)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for init
    fi

    CFG_DIR="/etc/linux_maint"
    # Prefer repo templates in repo mode; in installed mode use PREFIX share templates.
    SRC_DIR="$REPO_ROOT/etc/linux_maint"
    if [[ "$MODE" == "installed" ]]; then
      ALT="$SHARE/templates/linux_maint"
      [[ -d "$ALT" ]] && SRC_DIR="$ALT"
    fi
    if [[ -z "$SRC_DIR" || ! -d "$SRC_DIR" ]]; then
      echo "ERROR: templates not found at $SRC_DIR" >&2
      echo "Run init from a git checkout:" >&2
      echo "  git clone https://github.com/ShenhavHezi/linux_Maint_Scripts.git" >&2
      echo "  cd linux_Maint_Scripts" >&2
      echo "  sudo ./bin/linux-maint init" >&2
      exit 1
    fi

    sudo mkdir -p "$CFG_DIR" "$CFG_DIR/baselines" "$CFG_DIR/baselines/ports" "$CFG_DIR/baselines/configs" "$CFG_DIR/baselines/users" "$CFG_DIR/baselines/sudoers"

    shopt -s nullglob
    for f in "$SRC_DIR"/*.example; do
      base="$(basename "$f" .example)"
      dest="$CFG_DIR/$base"
      if [[ -e "$dest" ]]; then
        echo "keep:   $dest (exists)"
      else
        sudo install -m 0644 "$f" "$dest"
        echo "create: $dest"
      fi
    done

    echo ""
    echo "Next steps:"
    echo "  - Edit /etc/linux_maint/servers.txt"
    echo "  - Run: sudo linux-maint doctor"
    ;;

  doctor)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for doctor
    fi

    echo "=== linux-maint doctor ==="
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    echo "wrapper=$wrapper"
    echo "libexec=$LIBEXEC"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    echo "== Files =="
    for path in "$wrapper" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"; do
      if [[ -e "$path" ]]; then ls -la "$path"; else echo "MISSING: $path"; fi
    done
    if [[ "$MODE" == "installed" ]]; then
      [[ -d "$LIBEXEC" ]] && ls -ld "$LIBEXEC" || echo "MISSING: $LIBEXEC"
    else
      [[ -d "$REPO_MONITORS" ]] && ls -ld "$REPO_MONITORS" || echo "MISSING: $REPO_MONITORS"
    fi

    echo "== Config =="
    for f in /etc/linux_maint/servers.txt /etc/linux_maint/excluded.txt /etc/linux_maint/services.txt /etc/linux_maint/emails.txt; do
      [[ -e "$f" ]] && echo "OK: $f" || echo "MISSING: $f"
    done

    echo ""
    echo "== systemd (installed mode) =="
    if command -v systemctl >/dev/null 2>&1; then
      for unit in linux-maint.timer linux-maint.service; do
        if systemctl list-unit-files --no-legend "$unit" 2>/dev/null | grep -q "^$unit"; then
          echo "UNIT: $unit"
          systemctl is-enabled "$unit" 2>/dev/null || true
          systemctl is-active "$unit" 2>/dev/null || true
        else
          echo "MISSING unit file: $unit"
        fi
      done
      echo ""
      echo "-- timers (linux-maint) --"
      systemctl list-timers --all --no-pager 2>/dev/null | grep -E "linux-maint\.timer|NEXT|^$" || true
      echo ""
      echo "-- journal (linux-maint.service, last 50 lines) --"
      journalctl -u linux-maint.service -n 50 --no-pager 2>/dev/null || true
    else
      echo "systemctl not found"
    fi

    echo "== Can write state/logs? =="
    for d in /var/log/health /var/log/inventory /var/lib/linux_maint /var/lock; do
      [[ -d "$d" ]] || { echo "NOTE: creating $d"; sudo mkdir -p "$d" 2>/dev/null || true; }
      if touch "$d/.lm_write_test" 2>/dev/null; then rm -f "$d/.lm_write_test"; echo "OK: writable $d"; else echo "WARN: not writable $d"; fi
    done

    echo "== Next recommended actions =="
    echo "- sudo linux-maint init      # if config is missing"
    echo "- sudo linux-maint preflight"
    echo "- sudo linux-maint run"
    ;;

  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac
